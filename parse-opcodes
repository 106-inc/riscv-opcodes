#!/usr/bin/python

import math
import sys
import tokenize

namelist = []
match = {}
mask = {}
arguments = {}
types = {}

arglut = {}
arglut['rd'] = (31,27)
arglut['rs1'] = (26,22)
arglut['rs2'] = (21,17)
arglut['rs3'] = (16,12)
arglut['rm'] = (11,9)
arglut['imm25'] = (31,7)
arglut['imm20'] = (26,7)
arglut['imm12'] = (21,10)
arglut['imm12hi'] = (31,27)
arglut['imm12lo'] = (16,10)
arglut['shamt'] = (15,10)
arglut['shamtw'] = (14,10)

arglut['crd'] = (9,5)
arglut['crs2'] = (9,5)
arglut['crs1'] = (14,10)
arglut['crds'] = (15,13)
arglut['crs2s'] = (15,13)
arglut['crs2bs'] = (7,5)
arglut['crs1s'] = (12,10)
arglut['cimm6'] = (15,10)
arglut['cimm10'] = (14,5)
arglut['cimm5'] = (9,5)

typelut = {} # 0=unimp,1=j,2=lui,3=imm,4=r,5=r4,6=ish,7=ishw,,8=r4rm,9=rrm,10=b
typelut[0x03] = 3
typelut[0x07] = 3
typelut[0x13] = 3
typelut[0x1B] = 3
typelut[0x23] = 10
typelut[0x27] = 10
typelut[0x2B] = 4
typelut[0x2F] = 4
typelut[0x33] = 4
typelut[0x37] = 2
typelut[0x3B] = 4
typelut[0x43] = 8
typelut[0x47] = 8
typelut[0x4B] = 8
typelut[0x4F] = 8
typelut[0x53] = 9
typelut[0x63] = 10
typelut[0x67] = 1
typelut[0x6B] = 3
typelut[0x6F] = 1
typelut[0x77] = 4
typelut[0x7B] = 4

# XXX RVC
for i in range(0,3):
  for j in range(0,8):
    typelut[j*4+i] = 0

# vector opcodes
typelut[0x0B] = 4
typelut[0x0F] = 4
typelut[0x73] = 4

opcode_base = 0
opcode_size = 7
funct_base = 7
funct_size = 3

def binary(n, digits=0):
  rep = bin(n)[2:]
  return rep if digits == 0 else ('0' * (digits - len(rep))) + rep

def make_disasm_table(match,mask):
  print '/* Automatically generated by parse-opcodes */'
  for name,match in match.iteritems():
    name2 = name.upper().replace('.','_')
    print '#define MATCH_%s %s' % (name2, hex(match))
    print '#define  MASK_%s %s' % (name2, hex(mask[name]))

def make_switch(match, mask, dir):
  switch_base = 0
  switch_size = 10
  switch_mask = ((1<<(switch_base+switch_size))-(1<<switch_base))

  f = open('%s/dispatch_decl.h' % dir, 'w')
  f.write('/* Automatically generated by parse-opcodes */\n')
  f.write('#define dispatch_index(insn) (((insn).bits >> %d) & %d)\n' % (switch_base, (1<<switch_size)-1))
  for opc in range(0,1<<switch_size):
    f.write('reg_t opcode_func_%03x(insn_t insn, reg_t pc);\n' % opc)
  f.close()

  f = open('%s/dispatch.h' % dir, 'w')
  f.write('/* Automatically generated by parse-opcodes */\n')
  f.write('typedef reg_t (*insn_func_t)(processor_t*, insn_t, reg_t);\n')
  f.write('const static insn_func_t dispatch_table[] = {\n')
  for opc in range(0,1<<switch_size):
    f.write('  (insn_func_t)&processor_t::opcode_func_%03x,\n' % opc)
  f.write('};\n')
  f.close()

  nfiles = 10
  for file in range(0, nfiles):
    f = open('%s/dispatch_%x.cc' % (dir, file), 'w')
    f.write('#include "insn_includes.h"\n\n')
    
    for opc in range(0, 1<<switch_size):
      if opc % nfiles != file:
        continue
      f.write('reg_t processor_t::opcode_func_%03x(insn_t insn, reg_t pc)\n' % opc)
      f.write('{\n')

      has_some_instruction = 0
      exact = 0
      for name in match.iterkeys():
        if ((opc << switch_base) & mask[name]) == (match[name] & mask[name] & switch_mask):
          has_some_instruction = 1
        if ((opc << switch_base) & mask[name]) == match[name] and (switch_mask & mask[name]) == mask[name]:
          exact = 1

      for name in match.iterkeys():
        name2 = name.replace('.','_')
        if ((opc << switch_base) & mask[name]) == (match[name] & mask[name] & switch_mask):
          if not exact:
            f.write('  if((insn.bits & 0x%x) == 0x%x)\n' % (mask[name],match[name]))
            f.write('  {\n')
          f.write('    reg_t npc = pc + insn_length(0x%08x);\n' % match[name])
          f.write('    #include "insns/%s.h"\n' % name2)
          f.write('    return npc;\n')
          if not exact:
            f.write('  }\n')

      if not exact:
        f.write('  throw trap_illegal_instruction;\n')

      f.write('}\n\n')

    f.close()

def yank(num,start,len):
  return (num >> start) & ((1 << len) - 1)

def str_arg(arg0,arg1,match,arguments):
  if arg0 in arguments:
    return arg0
  elif arg1 in arguments:
    return arg1
  else:
    start = arglut[arg0][1]
    len = arglut[arg0][0] - arglut[arg0][1] + 1
    return binary(yank(match,start,len),len)

def str_inst(name,arguments):
  ret = name.upper() + ' '
  if 'imm12hi' in arguments and 'imm12lo' in arguments:
    arguments.remove('imm12hi')
    arguments.remove('imm12lo')
    arguments.append('imm12')
  for idx in range(len(arguments)):
    ret = ret + arguments[idx]
    if idx != len(arguments)-1:
      ret = ret + ','
  ret = ret.replace(',rm','[,rm]')
  return ret

def print_unimp_type(name,match,arguments):
  print """
&
\\multicolumn{10}{|c|}{%s} & %s \\\\
\\cline{2-11}
  """ % \
  ( \
    '0'*32, \
    'UNIMP' \
  )

def print_j_type(name,match,arguments):
  print """
&
\\multicolumn{9}{|c|}{%s} &
\\multicolumn{1}{c|}{%s} & %s \\\\
\\cline{2-11}
  """ % \
  ( \
    str_arg('imm25','',match,arguments), \
    binary(yank(match,opcode_base,opcode_size),opcode_size), \
    str_inst(name,arguments) \
  )

def print_lui_type(name,match,arguments):
  print """
&
\\multicolumn{1}{|c|}{%s} &
\\multicolumn{8}{c|}{%s} &
\\multicolumn{1}{c|}{%s} & %s \\\\
\\cline{2-11}
  """ % \
  ( \
    str_arg('rd','',match,arguments), \
    str_arg('imm20','',match,arguments), \
    binary(yank(match,opcode_base,opcode_size),opcode_size), \
    str_inst(name,arguments) \
  )

def print_b_type(name,match,arguments):
  print """
&
\\multicolumn{1}{|c|}{%s} &
\\multicolumn{1}{c|}{%s} &
\\multicolumn{1}{c|}{%s} &
\\multicolumn{4}{c|}{%s} &
\\multicolumn{2}{c|}{%s} &
\\multicolumn{1}{c|}{%s} & %s \\\\
\\cline{2-11}
  """ % \
  ( \
    str_arg('imm12hi','',match,arguments), \
    str_arg('rs1','',match,arguments), \
    str_arg('rs2','',match,arguments), \
    str_arg('imm12lo','',match,arguments), \
    binary(yank(match,funct_base,funct_size),funct_size), \
    binary(yank(match,opcode_base,opcode_size),opcode_size), \
    str_inst(name,arguments) \
  )

def print_i_type(name,match,arguments):
  print """
&
\\multicolumn{1}{|c|}{%s} &
\\multicolumn{1}{c|}{%s} &
\\multicolumn{5}{c|}{%s} &
\\multicolumn{2}{c|}{%s} &
\\multicolumn{1}{c|}{%s} & %s \\\\
\\cline{2-11}
  """ % \
  ( \
    str_arg('rd','',match,arguments), \
    str_arg('rs1','',match,arguments), \
    str_arg('imm12','',match,arguments), \
    binary(yank(match,funct_base,funct_size),funct_size), \
    binary(yank(match,opcode_base,opcode_size),opcode_size), \
    str_inst(name,arguments) \
  )

def print_ish_type(name,match,arguments):
  print """
&
\\multicolumn{1}{|c|}{%s} &
\\multicolumn{1}{c|}{%s} &
\\multicolumn{2}{c|}{%s} &
\\multicolumn{3}{c|}{%s} &
\\multicolumn{2}{c|}{%s} &
\\multicolumn{1}{c|}{%s} & %s \\\\
\\cline{2-11}
  """ % \
  ( \
    str_arg('rd','',match,arguments), \
    str_arg('rs1','',match,arguments), \
    binary(yank(match,16,6),6), \
    str_arg('shamt','',match,arguments), \
    binary(yank(match,funct_base,funct_size),funct_size), \
    binary(yank(match,opcode_base,opcode_size),opcode_size), \
    str_inst(name,arguments) \
  )

def print_ishw_type(name,match,arguments):
  print """
&
\\multicolumn{1}{|c|}{%s} &
\\multicolumn{1}{c|}{%s} &
\\multicolumn{3}{c|}{%s} &
\\multicolumn{2}{c|}{%s} &
\\multicolumn{2}{c|}{%s} &
\\multicolumn{1}{c|}{%s} & %s \\\\
\\cline{2-11}
  """ % \
  ( \
    str_arg('rd','',match,arguments), \
    str_arg('rs1','',match,arguments), \
    binary(yank(match,15,7),7), \
    str_arg('shamtw','',match,arguments), \
    binary(yank(match,funct_base,funct_size),funct_size), \
    binary(yank(match,opcode_base,opcode_size),opcode_size), \
    str_inst(name,arguments) \
  )

def print_r_type(name,match,arguments):
  print """
&
\\multicolumn{1}{|c|}{%s} &
\\multicolumn{1}{c|}{%s} &
\\multicolumn{1}{c|}{%s} &
\\multicolumn{4}{c|}{%s} &
\\multicolumn{2}{c|}{%s} &
\\multicolumn{1}{c|}{%s} & %s \\\\
\\cline{2-11}
  """ % \
  ( \
    str_arg('rd','',match,arguments), \
    str_arg('rs1','',match,arguments), \
    str_arg('rs2','',match,arguments), \
    binary(yank(match,10,7),7), \
    binary(yank(match,funct_base,funct_size),funct_size), \
    binary(yank(match,opcode_base,opcode_size),opcode_size), \
    str_inst(name,arguments) \
  )

def print_r4_type(name,match,arguments):
  print """
&
\\multicolumn{1}{|c|}{%s} &
\\multicolumn{1}{c|}{%s} &
\\multicolumn{1}{c|}{%s} &
\\multicolumn{3}{c|}{%s} &
\\multicolumn{3}{c|}{%s} &
\\multicolumn{1}{c|}{%s} & %s \\\\
\\cline{2-11}
  """ % \
  ( \
    str_arg('rd','',match,arguments), \
    str_arg('rs1','',match,arguments), \
    str_arg('rs2','',match,arguments), \
    str_arg('rs3','',match,arguments), \
    binary(yank(match,7,5),5), \
    binary(yank(match,opcode_base,opcode_size),opcode_size), \
    str_inst(name,arguments) \
  )

def print_r_rm_type(name,match,arguments):
  print """
&
\\multicolumn{1}{|c|}{%s} &
\\multicolumn{1}{c|}{%s} &
\\multicolumn{1}{c|}{%s} &
\\multicolumn{3}{c|}{%s} &
\\multicolumn{2}{c|}{%s} &
\\multicolumn{1}{c|}{%s} &
\\multicolumn{1}{c|}{%s} & %s \\\\
\\cline{2-11}
  """ % \
  ( \
    str_arg('rd','',match,arguments), \
    str_arg('rs1','',match,arguments), \
    str_arg('rs2','',match,arguments), \
    binary(yank(match,12,5),5), \
    str_arg('rm','',match,arguments), \
    binary(yank(match,7,2),2), \
    binary(yank(match,opcode_base,opcode_size),opcode_size), \
    str_inst(name,arguments) \
  )

def print_r4_rm_type(name,match,arguments):
  print """
&
\\multicolumn{1}{|c|}{%s} &
\\multicolumn{1}{c|}{%s} &
\\multicolumn{1}{c|}{%s} &
\\multicolumn{3}{c|}{%s} &
\\multicolumn{2}{c|}{%s} &
\\multicolumn{1}{c|}{%s} &
\\multicolumn{1}{c|}{%s} & %s \\\\
\\cline{2-11}
  """ % \
  ( \
    str_arg('rd','',match,arguments), \
    str_arg('rs1','',match,arguments), \
    str_arg('rs2','',match,arguments), \
    str_arg('rs3','',match,arguments), \
    str_arg('rm','',match,arguments), \
    binary(yank(match,7,2),2), \
    binary(yank(match,opcode_base,opcode_size),opcode_size), \
    str_inst(name,arguments) \
  )

def print_header():
  print """
\\newpage

\\begin{table}[p]
\\begin{small}
\\begin{center}
\\begin{tabular}{rccccccccccl}
                &
\\hspace*{0.6in} &
\\hspace*{0.3in} &
\\hspace*{0.1in} &
\\hspace*{0.1in} &
\\hspace*{0.2in} &
\\hspace*{0.2in} &
\\hspace*{0.1in} &
\\hspace*{0.3in} &
\\hspace*{0.3in} &
\\hspace*{0.3in} \\\\
                      &
\\instbitrange{31}{27} &
\\instbitrange{26}{22} &
\\instbitrange{21}{17} &
\\instbit{16} &
\\instbit{15} &
\\instbitrange{14}{12} &
\\instbitrange{11}{10} &
\\instbit{9} &
\\instbitrange{8}{7} &
\\instbitrange{6}{0} \\\\
\\cline{2-11}
&
\\multicolumn{9}{|c|}{jump target} &
\\multicolumn{1}{c|}{opcode} & J-type \\\\
\\cline{2-11}
&
\\multicolumn{1}{|c|}{rd} &
\\multicolumn{8}{c|}{LUI-immediate} &
\\multicolumn{1}{c|}{opcode} & LUI-type \\\\
\\cline{2-11}
&
\\multicolumn{1}{|c|}{rd} &
\\multicolumn{1}{c|}{rs1} &
\\multicolumn{1}{c|}{imm[11:7]} &
\\multicolumn{4}{c|}{imm[6:0]} &
\\multicolumn{2}{c|}{funct3} &
\\multicolumn{1}{c|}{opcode} & I-type \\\\
\\cline{2-11}
&
\\multicolumn{1}{|c|}{imm[11:7]} &
\\multicolumn{1}{c|}{rs1} &
\\multicolumn{1}{c|}{rs2} &
\\multicolumn{4}{c|}{imm[6:0]} &
\\multicolumn{2}{c|}{funct3} &
\\multicolumn{1}{c|}{opcode} & B-type \\\\
\\cline{2-11}
&
\\multicolumn{1}{|c|}{rd} &
\\multicolumn{1}{c|}{rs1} &
\\multicolumn{1}{c|}{rs2} &
\\multicolumn{6}{c|}{funct10} &
\\multicolumn{1}{c|}{opcode} & R-type \\\\
\\cline{2-11}
&
\\multicolumn{1}{|c|}{rd} &
\\multicolumn{1}{c|}{rs1} &
\\multicolumn{1}{c|}{rs2} &
\\multicolumn{3}{c|}{rs3} &
\\multicolumn{3}{c|}{funct5} &
\\multicolumn{1}{c|}{opcode} & R4-type \\\\
\\cline{2-11}
  """

def print_subtitle(title):
  print """
&
\\multicolumn{10}{c}{} & \\\\
&
\\multicolumn{10}{c}{\\bf %s} & \\\\
\\cline{2-11}
  """ % title

def print_footer(caption):
  print """
\\end{tabular}
\\end{center}
\\end{small}
%s
\\label{instr-table}
\\end{table}
  """ % (caption and '\\caption{Instruction listing for RISC-V}' or '')

def print_insts(opcode,name,type,min,max):
  for n in namelist:
    if yank(match[n],opcode_base,opcode_size) == opcode or n == name:
      if type == -1 or types[n] == type:
        if types[n] == 0:
          print_unimp_type(n,match[n],arguments[n])
        elif types[n] == 1:
          print_j_type(n,match[n],arguments[n])
        elif types[n] == 2:
          print_lui_type(n,match[n],arguments[n])
        elif types[n] == 3:
          print_i_type(n,match[n],arguments[n])
        elif types[n] == 4 \
          and (min == -1 or yank(match[n],5,10) >= min) \
          and (max == -1 or yank(match[n],5,10) <= max):
          print_r_type(n,match[n],arguments[n])
        elif types[n] == 5:
          print_r4_type(n,match[n],arguments[n])
        elif types[n] == 6:
          print_ish_type(n,match[n],arguments[n])
        elif types[n] == 7:
          print_ishw_type(n,match[n],arguments[n])
        elif types[n] == 8:
          print_r4_rm_type(n,match[n],arguments[n])
        elif types[n] == 9:
          print_r_rm_type(n,match[n],arguments[n])
        elif types[n] == 10:
          print_b_type(n,match[n],arguments[n])

def make_latex_table():
  print_header()
  print_subtitle('Unimplemented Instruction')
  print_insts(0x00,'',-1,-1,-1)
  print_subtitle('Control Transfer Instructions')
  print_insts(0x67,'',-1,-1,-1)
  print_insts(0x6f,'',-1,-1,-1)
  print_insts(0x63,'',-1,-1,-1)
  print_insts(0x6b,'',-1,-1,-1)
  print_subtitle('Memory Instructions')
  print_insts(0x03,'',-1,-1,-1)
  print_insts(0x23,'',-1,-1,-1)
  print_subtitle('Atomic Memory Instructions')
  print_insts(0x2b,'',-1,-1,-1)
  print_footer(0)

  print_header()
  print_subtitle('Integer Compute Instructions')
  print_insts(0x13,'',-1,-1,-1)
  print_insts(0x33,'',-1,-1,-1)
  print_insts(0x37,'',-1,-1,-1)
  print_subtitle('32-bit Integer Compute Instructions')
  print_insts(0x1b,'',-1,-1,-1)
  print_insts(0x3b,'',-1,-1,-1)
  print_footer(0)

  print_header()
  print_subtitle('Floating-Point Memory Instructions')
  print_insts(0x07,'',-1,-1,-1)
  print_insts(0x27,'',-1,-1,-1)
  print_subtitle('Floating-Point Compute Instructions')
  print_insts(-1,'fadd.s',-1,-1,-1)
  print_insts(-1,'fsub.s',-1,-1,-1)
  print_insts(-1,'fmul.s',-1,-1,-1)
  print_insts(-1,'fdiv.s',-1,-1,-1)
  print_insts(-1,'fsqrt.s',-1,-1,-1)
  print_insts(-1,'fmin.s',-1,-1,-1)
  print_insts(-1,'fmax.s',-1,-1,-1)
  print_insts(-1,'fadd.d',-1,-1,-1)
  print_insts(-1,'fsub.d',-1,-1,-1)
  print_insts(-1,'fmul.d',-1,-1,-1)
  print_insts(-1,'fdiv.d',-1,-1,-1)
  print_insts(-1,'fsqrt.d',-1,-1,-1)
  print_insts(-1,'fmin.d',-1,-1,-1)
  print_insts(-1,'fmax.d',-1,-1,-1)
  print_insts(-1,'fmadd.s',-1,-1,-1)
  print_insts(-1,'fmsub.s',-1,-1,-1)
  print_insts(-1,'fnmsub.s',-1,-1,-1)
  print_insts(-1,'fnmadd.s',-1,-1,-1)
  print_insts(-1,'fmadd.d',-1,-1,-1)
  print_insts(-1,'fmsub.d',-1,-1,-1)
  print_insts(-1,'fnmsub.d',-1,-1,-1)
  print_insts(-1,'fnmadd.d',-1,-1,-1)
  print_footer(0)

  print_header()
  print_subtitle('Floating-Point Move \& Conversion Instructions')
  print_insts(-1,'fsgnj.s',-1,-1,-1)
  print_insts(-1,'fsgnjn.s',-1,-1,-1)
  print_insts(-1,'fsgnjx.s',-1,-1,-1)
  print_insts(-1,'fsgnj.d',-1,-1,-1)
  print_insts(-1,'fsgnjn.d',-1,-1,-1)
  print_insts(-1,'fsgnjx.d',-1,-1,-1)
  print_insts(-1,'fcvt.s.d',-1,-1,-1)
  print_insts(-1,'fcvt.d.s',-1,-1,-1)
  print_subtitle('Integer to Floating-Point Move \& Conversion Instructions')
  print_insts(-1,'fcvt.s.l',-1,-1,-1)
  print_insts(-1,'fcvt.s.lu',-1,-1,-1)
  print_insts(-1,'fcvt.s.w',-1,-1,-1)
  print_insts(-1,'fcvt.s.wu',-1,-1,-1)
  print_insts(-1,'fcvt.d.l',-1,-1,-1)
  print_insts(-1,'fcvt.d.lu',-1,-1,-1)
  print_insts(-1,'fcvt.d.w',-1,-1,-1)
  print_insts(-1,'fcvt.d.wu',-1,-1,-1)
  print_insts(-1,'mxtf.s',-1,-1,-1)
  print_insts(-1,'mxtf.d',-1,-1,-1)
  print_insts(-1,'mtfsr',-1,-1,-1)
  print_subtitle('Floating-Point to Integer Move \& Conversion Instructions')
  print_insts(-1,'fcvt.l.s',-1,-1,-1)
  print_insts(-1,'fcvt.lu.s',-1,-1,-1)
  print_insts(-1,'fcvt.w.s',-1,-1,-1)
  print_insts(-1,'fcvt.wu.s',-1,-1,-1)
  print_insts(-1,'fcvt.l.d',-1,-1,-1)
  print_insts(-1,'fcvt.lu.d',-1,-1,-1)
  print_insts(-1,'fcvt.w.d',-1,-1,-1)
  print_insts(-1,'fcvt.wu.d',-1,-1,-1)
  print_insts(-1,'mftx.s',-1,-1,-1)
  print_insts(-1,'mftx.d',-1,-1,-1)
  print_insts(-1,'mffsr',-1,-1,-1)
  print_footer(0)

  print_header()
  print_subtitle('Floating-Point Compare Instructions')
  print_insts(-1,'feq.s',-1,-1,-1)
  print_insts(-1,'flt.s',-1,-1,-1)
  print_insts(-1,'fle.s',-1,-1,-1)
  print_insts(-1,'feq.d',-1,-1,-1)
  print_insts(-1,'flt.d',-1,-1,-1)
  print_insts(-1,'fle.d',-1,-1,-1)
  print_subtitle('Miscellaneous Memory Instructions')
  print_insts(0x2f,'',-1,-1,-1)
  print_subtitle('System Instructions')
  print_insts(0x77,'',-1,-1,-1)
  print_footer(1)

def str_verilog_arg(arg0,arg1,match,arguments):
  if arg0 in arguments:
    return '?' * (arglut[arg0][0] - arglut[arg0][1] + 1)
  elif arg1 in arguments:
    return '?' * (arglut[arg0][0] - arglut[arg0][1] + 1)
  else:
    start = arglut[arg0][1]
    len = arglut[arg0][0] - arglut[arg0][1] + 1
    return binary(yank(match,start,len),len)

def print_verilog_unimp_type(name,match,arguments):
  print "`define %-10s 32'b%s" % \
  ( \
    name.replace('.','_').upper(), \
    '0'*32 \
  )

def print_verilog_j_type(name,match,arguments):
  print "`define %-10s 32'b%s_%s" % \
  ( \
    name.replace('.','_').upper(), \
    str_verilog_arg('imm25','',match,arguments), \
    binary(yank(match,0,7),7) \
  )

def print_verilog_lui_type(name,match,arguments):
  print "`define %-10s 32'b%s_%s_%s" % \
  ( \
    name.replace('.','_').upper(), \
    str_verilog_arg('rd','',match,arguments), \
    str_verilog_arg('imm20','',match,arguments), \
    binary(yank(match,0,7),7) \
  )

def print_verilog_b_type(name,match,arguments):
  print "`define %-10s 32'b%s_%s_%s_%s_%s_%s" % \
  ( \
    name.replace('.','_').upper(), \
    str_verilog_arg('imm12hi','',match,arguments), \
    str_verilog_arg('rs1','',match,arguments), \
    str_verilog_arg('rs2','',match,arguments), \
    str_verilog_arg('imm12lo','',match,arguments), \
    binary(yank(match,7,3),3), \
    binary(yank(match,0,7),7) \
  )

def print_verilog_i_type(name,match,arguments):
  print "`define %-10s 32'b%s_%s_%s_%s_%s" % \
  ( \
    name.replace('.','_').upper(), \
    str_verilog_arg('rd','',match,arguments), \
    str_verilog_arg('rs1','',match,arguments), \
    str_verilog_arg('imm12','',match,arguments), \
    binary(yank(match,7,3),3), \
    binary(yank(match,0,7),7) \
  )

def print_verilog_ish_type(name,match,arguments):
  print "`define %-10s 32'b%s_%s_%s_%s_%s_%s" % \
  ( \
    name.replace('.','_').upper(), \
    str_verilog_arg('rd','',match,arguments), \
    str_verilog_arg('rs1','',match,arguments), \
    binary(yank(match,16,6),6), \
    str_verilog_arg('shamt','',match,arguments), \
    binary(yank(match,7,3),3), \
    binary(yank(match,0,7),7) \
  )

def print_verilog_ishw_type(name,match,arguments):
  print "`define %-10s 32'b%s_%s_%s_0_%s_%s_%s" % \
  ( \
    name.replace('.','_').upper(), \
    str_verilog_arg('rd','',match,arguments), \
    str_verilog_arg('rs1','',match,arguments), \
    binary(yank(match,16,6),6), \
    str_verilog_arg('shamtw','',match,arguments), \
    binary(yank(match,7,3),3), \
    binary(yank(match,0,7),7) \
  )

def print_verilog_r4_type(name,match,arguments):
  print "`define %-10s 32'b%s_%s_%s_%s_%s_%s_%s" % \
  ( \
    name.replace('.','_').upper(), \
    str_verilog_arg('rd','',match,arguments), \
    str_verilog_arg('rs1','',match,arguments), \
    str_verilog_arg('rs2','',match,arguments), \
    str_verilog_arg('rs3','',match,arguments), \
    binary(yank(match,9,3),3), \
    binary(yank(match,7,2),2), \
    binary(yank(match,0,7),7) \
  )

def print_verilog_r4_rm_type(name,match,arguments):
  print "`define %-10s 32'b%s_%s_%s_%s_%s_%s_%s" % \
  ( \
    name.replace('.','_').upper(), \
    str_verilog_arg('rd','',match,arguments), \
    str_verilog_arg('rs1','',match,arguments), \
    str_verilog_arg('rs2','',match,arguments), \
    str_verilog_arg('rs3','',match,arguments), \
    str_verilog_arg('rm','',match,arguments), \
    binary(yank(match,7,2),2), \
    binary(yank(match,0,7),7) \
  )

def print_verilog_r_rm_type(name,match,arguments):
  print "`define %-10s 32'b%s_%s_%s_%s_%s_%s_%s" % \
  ( \
    name.replace('.','_').upper(), \
    str_verilog_arg('rd','',match,arguments), \
    str_verilog_arg('rs1','',match,arguments), \
    str_verilog_arg('rs2','',match,arguments), \
    binary(yank(match,12,5),5), \
    str_verilog_arg('rm','',match,arguments), \
    binary(yank(match,7,2),2), \
    binary(yank(match,0,7),7) \
  )

def print_verilog_r_type(name,match,arguments):
  print "`define %-10s 32'b%s_%s_%s_%s_%s" % \
  ( \
    name.replace('.','_').upper(), \
    str_verilog_arg('rd','',match,arguments), \
    str_verilog_arg('rs1','',match,arguments), \
    str_verilog_arg('rs2','',match,arguments), \
    binary(yank(match,7,10),10), \
    binary(yank(match,0,7),7) \
  )

def make_verilog():
  for name in namelist:
    if types[name] == 0:
      print_verilog_unimp_type(name,match[name],arguments[name])
    elif types[name] == 1:
      print_verilog_j_type(name,match[name],arguments[name])
    elif types[name] == 2:
      print_verilog_lui_type(name,match[name],arguments[name])
    elif types[name] == 3:
      print_verilog_i_type(name,match[name],arguments[name])
    elif types[name] == 4:
      print_verilog_r_type(name,match[name],arguments[name])
    elif types[name] == 5:
      print_verilog_r4_type(name,match[name],arguments[name])
    elif types[name] == 6:
      print_verilog_ish_type(name,match[name],arguments[name])
    elif types[name] == 7:
      print_verilog_ishw_type(name,match[name],arguments[name])
    elif types[name] == 8:
      print_verilog_r4_rm_type(name,match[name],arguments[name])
    elif types[name] == 9:
      print_verilog_r_rm_type(name,match[name],arguments[name])
    elif types[name] == 10:
      print_verilog_b_type(name,match[name],arguments[name])

for line in sys.stdin:
  line = line.partition('#')
  tokens = line[0].split()

  if len(tokens) == 0:
    continue
  assert len(tokens) >= 2

  name = tokens[0]
  mymatch = 0
  mymask = 0
  cover = 0

  if not name in arguments.keys():
    arguments[name] = []

  for token in tokens[1:]:
    if len(token.split('=')) == 2:
      tmp = token.split('=')
      val = int(tmp[1],0)
      if len(tmp[0].split('..')) == 2:
        tmp = tmp[0].split('..')
        hi = int(tmp[0])
        lo = int(tmp[1])
        if hi <= lo:
          sys.exit("%s: bad range %d..%d" % (name,hi,lo))
      else:
        hi = lo = int(tmp[0])
      if val >= (1 << (hi-lo+1)):
        sys.exit("%s: bad value %d for range %d..%d" % (name,val,hi,lo))
      mymatch = mymatch | (val << lo)
      mymask = mymask | ((1<<(hi+1))-(1<<lo))
      if cover & ((1<<(hi+1))-(1<<lo)):
        sys.exit("%s: overspecified" % name)
      cover = cover | ((1<<(hi+1))-(1<<lo))
    elif token in arglut:
      if cover & ((1<<(arglut[token][0]+1))-(1<<arglut[token][1])):
        sys.exit("%s: overspecified" % name)
      cover = cover | ((1<<(arglut[token][0]+1))-(1<<arglut[token][1]))

      arguments[name].append(token)
    else:
      sys.exit("%s: unknown token %s" % (name,token))

  if not (cover == 0xFFFFFFFF or cover == 0xFFFF):
    sys.exit("%s: not all bits are covered" % name)

  for name2,match2 in match.iteritems():
    if (match2 & mymask) == mymatch:
      sys.exit("%s and %s overlap" % (name,name2))

  mask[name] = mymask
  match[name] = mymatch
  types[name] = typelut[yank(mymatch,0,7)]
  if 'shamtw' in arguments[name]:
    types[name] = 7
  elif 'imm12' in arguments[name]:
    types[name] = 3
  elif 'shamt' in arguments[name]:
    types[name] = 6
  elif types[name] == 4 and 'rs3' in arguments[name]:
    types[name] = 5
  elif types[name] == 5 and 'rm' in arguments[name]:
    types[name] = 8
  elif types[name] == 4 and 'rm' in arguments[name]:
    types[name] = 9
  elif name == 'vsetvl':
    types[name] = 3

  namelist.append(name)

if sys.argv[1] == '-tex':
  make_latex_table()
elif sys.argv[1] == '-verilog':
  make_verilog()
elif sys.argv[1] == '-disasm':
  make_disasm_table(match,mask)
elif sys.argv[1] == '-switch':
  make_switch(match,mask,sys.argv[2])
else:
  assert 0
